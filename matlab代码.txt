clc;% Auto-generated by stereoCalibrator app on 31-Aug-2025
%-------------------------------------------------------

% Define images to process
imageFileNames1 = {'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\1.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\10.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\11.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\12.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\2.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\3.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\4.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\5.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\6.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\7.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\8.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\left\9.jpg',...
    };
imageFileNames2 = {'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\1.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\10.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\11.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\12.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\2.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\3.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\4.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\5.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\6.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\7.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\8.jpg',...
    'G:\MyAll\githubcode\recreat3D\tempcode\p2_3D\steps3\picture_new\point_pic\right\9.jpg',...
    };

% Detect calibration pattern in images
detector = vision.calibration.stereo.CheckerboardDetector();
[imagePoints, imagesUsed] = detectPatternPoints(detector, imageFileNames1, imageFileNames2);

% Generate world coordinates for the planar patten keypoints
squareSize = 8.200000e+00;  % in units of 'millimeters'
worldPoints = generateWorldPoints(detector, 'SquareSize', squareSize);

% Read one of the images from the first stereo pair
I1 = imread(imageFileNames1{1});
[mrows, ncols, ~] = size(I1);

% Calibrate the camera
[stereoParams, pairsUsed, estimationErrors] = estimateCameraParameters(imagePoints, worldPoints, ...
    'EstimateSkew', false, 'EstimateTangentialDistortion', true, ...
    'NumRadialDistortionCoefficients', 3, 'WorldUnits', 'millimeters', ...
    'InitialIntrinsicMatrix', [], 'InitialRadialDistortion', [], ...
    'ImageSize', [mrows, ncols]);

% --- 添加的代码：批量保存角点检测图 ---
% 创建目录来保存图片和数据
leftOutputFolder = 'G:/MyProject/Left_Detection_Images';
rightOutputFolder = 'G:/MyProject/Right_Detection_Images';
dataOutputFolder = 'G:/MyProject/Calibration_Data';
if ~exist(leftOutputFolder, 'dir')
    mkdir(leftOutputFolder);
end
if ~exist(rightOutputFolder, 'dir')
    mkdir(rightOutputFolder);
end
if ~exist(dataOutputFolder, 'dir')
    mkdir(dataOutputFolder);
end

% 获取棋盘格尺寸
boardSize = detector.BoardSize;

% 检查 imagePoints 的类型和维度
fprintf('imagePoints 类型: %s\n', class(imagePoints));
fprintf('imagePoints 维度: %s\n', mat2str(size(imagePoints)));

% 创建角点坐标文件
cornerDataFile = fopen(fullfile(dataOutputFolder, 'corner_points.txt'), 'w');
fprintf(cornerDataFile, 'Image_Index, Camera, Point_Index, X, Y\n');

% 遍历所有图像
for i = 1:length(imageFileNames1)
    % 处理左图像
    if imagesUsed(i) % 只处理成功检测到角点的图像
        try
            % 读取左图像
            leftImage = imread(imageFileNames1{i});
            
            % 获取左图像角点 - 使用正确的索引方式
            leftPoints = squeeze(imagePoints(:, :, i, 1));
            
            % 保存角点坐标到文件
            for j = 1:size(leftPoints, 1)
                fprintf(cornerDataFile, '%d, left, %d, %.4f, %.4f\n', i, j, leftPoints(j,1), leftPoints(j,2));
            end
            
            % 绘制角点 - 使用更小的标记
            fig = figure('Visible', 'off');
            imshow(leftImage);
            hold on;
            
            % 只绘制角点，不连接线，使用更小的标记
            plot(leftPoints(:,1), leftPoints(:,2), 'r+', 'MarkerSize', 6, 'LineWidth', 1.5);
            
            % 只在四个角点绘制圆圈标记
            corners = [1, boardSize(2)-1, (boardSize(1)-2)*(boardSize(2)-1)+1, (boardSize(1)-1)*(boardSize(2)-1)];
            plot(leftPoints(corners,1), leftPoints(corners,2), 'bo', 'MarkerSize', 8, 'LineWidth', 2);
            
            title(sprintf('Left Image %d - Detected Corners', i));
            hold off;
            
            % 保存图像
            [~, name, ext] = fileparts(imageFileNames1{i});
            outputPath = fullfile(leftOutputFolder, sprintf('Left_Image_%d_%s.png', i, name));
            print(fig, outputPath, '-dpng', '-r300'); % 高分辨率保存
            close(fig);
        catch ME
            fprintf('处理左图像 %d 时出错: %s\n', i, ME.message);
        end
    else
        fprintf('左图像 %d 未检测到角点\n', i);
    end
    
    % 处理右图像
    if imagesUsed(i) % 只处理成功检测到角点的图像
        try
            % 读取右图像
            rightImage = imread(imageFileNames2{i});
            
            % 获取右图像角点 - 使用正确的索引方式
            rightPoints = squeeze(imagePoints(:, :, i, 2));
            
            % 保存角点坐标到文件
            for j = 1:size(rightPoints, 1)
                fprintf(cornerDataFile, '%d, right, %d, %.4f, %.4f\n', i, j, rightPoints(j,1), rightPoints(j,2));
            end
            
            % 绘制角点 - 使用更小的标记
            fig = figure('Visible', 'off');
            imshow(rightImage);
            hold on;
            
            % 只绘制角点，不连接线，使用更小的标记
            plot(rightPoints(:,1), rightPoints(:,2), 'r+', 'MarkerSize', 6, 'LineWidth', 1.5);
            
            % 只在四个角点绘制圆圈标记
            corners = [1, boardSize(2)-1, (boardSize(1)-2)*(boardSize(2)-1)+1, (boardSize(1)-1)*(boardSize(2)-1)];
            plot(rightPoints(corners,1), rightPoints(corners,2), 'bo', 'MarkerSize', 8, 'LineWidth', 2);
            
            title(sprintf('Right Image %d - Detected Corners', i));
            hold off;
            
            % 保存图像
            [~, name, ext] = fileparts(imageFileNames2{i});
            outputPath = fullfile(rightOutputFolder, sprintf('Right_Image_%d_%s.png', i, name));
            print(fig, outputPath, '-dpng', '-r300'); % 高分辨率保存
            close(fig);
        catch ME
            fprintf('处理右图像 %d 时出错: %s\n', i, ME.message);
        end
    else
        fprintf('右图像 %d 未检测到角点\n', i);
    end
end

fclose(cornerDataFile);

fprintf('左图像检测图已保存至: %s\n', leftOutputFolder);
fprintf('右图像检测图已保存至: %s\n', rightOutputFolder);
fprintf('角点坐标数据已保存至: %s\n', fullfile(dataOutputFolder, 'corner_points.txt'));

% --- 添加的代码：保存相机参数 ---
% 保存相机内参和畸变系数
camParamsFile = fopen(fullfile(dataOutputFolder, 'camera_parameters.txt'), 'w');
fprintf(camParamsFile, '=== Camera 1 Intrinsics ===\n');
fprintf(camParamsFile, 'Focal Length: [%.4f, %.4f]\n', stereoParams.CameraParameters1.FocalLength);
fprintf(camParamsFile, 'Principal Point: [%.4f, %.4f]\n', stereoParams.CameraParameters1.PrincipalPoint);
fprintf(camParamsFile, 'Radial Distortion: [%.6f, %.6f, %.6f]\n', stereoParams.CameraParameters1.RadialDistortion);
fprintf(camParamsFile, 'Tangential Distortion: [%.6f, %.6f]\n', stereoParams.CameraParameters1.TangentialDistortion);

fprintf(camParamsFile, '\n=== Camera 2 Intrinsics ===\n');
fprintf(camParamsFile, 'Focal Length: [%.4f, %.4f]\n', stereoParams.CameraParameters2.FocalLength);
fprintf(camParamsFile, 'Principal Point: [%.4f, %.4f]\n', stereoParams.CameraParameters2.PrincipalPoint);
fprintf(camParamsFile, 'Radial Distortion: [%.6f, %.6f, %.6f]\n', stereoParams.CameraParameters2.RadialDistortion);
fprintf(camParamsFile, 'Tangential Distortion: [%.6f, %.6f]\n', stereoParams.CameraParameters2.TangentialDistortion);

fprintf(camParamsFile, '\n=== Camera 2 Relative to Camera 1 ===\n');
fprintf(camParamsFile, 'Rotation Matrix:\n');
fprintf(camParamsFile, '%.6f, %.6f, %.6f\n', stereoParams.RotationOfCamera2');
fprintf(camParamsFile, 'Translation Vector: [%.6f, %.6f, %.6f]\n', stereoParams.TranslationOfCamera2);

fclose(camParamsFile);
fprintf('相机参数已保存至: %s\n', fullfile(dataOutputFolder, 'camera_parameters.txt'));

% 保存为OpenCV可读取的XML格式
% === MATLAB-OpenCV 坐标系统和矩阵格式转换说明 ===
% 
% 1. 矩阵存储差异：
%    - MATLAB和OpenCV都使用行优先存储
%    - 但矩阵元素组织方式不同
% 
% 2. 内参矩阵格式：
%    - MATLAB格式: [fx 0 0; 0 fy 0; cx cy 1]
%    - OpenCV格式: [fx 0 cx; 0 fy cy; 0 0 1]
%    - 转换：将cx,cy从第3行移动到第1,2行的第3列
% 
% 3. 旋转矩阵：
%    - MATLAB输出的RotationOfCamera2无需转置
%    - 直接使用，保持3x3矩阵的行优先存储
% 
% 4. 单位一致性：
%    - 棋盘格尺寸：8.2毫米 (squareSize)
%    - 平移向量：毫米单位 (TranslationOfCamera2)
%    - 焦距：像素单位 (FocalLength)
%    - 主点：像素单位 (PrincipalPoint)
% 
% 5. 畸变系数顺序：
%    - OpenCV: [k1, k2, p1, p2, k3]
%    - MATLAB: RadialDistortion=[k1,k2,k3], TangentialDistortion=[p1,p2]
%    - 按OpenCV顺序重新组织
xmlFileName = fullfile(dataOutputFolder, 'stereo_calibration.xml');
fid = fopen(xmlFileName, 'w');
fprintf(fid, '<?xml version="1.0"?>\n');
fprintf(fid, '<opencv_storage>\n');

% 相机1内参 - 修正：MATLAB矩阵格式转换为OpenCV格式
fprintf(fid, '<Camera1_Intrinsic type_id="opencv-matrix">\n');
fprintf(fid, '  <rows>3</rows>\n');
fprintf(fid, '  <cols>3</cols>\n');
fprintf(fid, '  <dt>d</dt>\n');
fprintf(fid, '  <data>\n');
% MATLAB IntrinsicMatrix格式: [fx 0 0; 0 fy 0; cx cy 1]
% OpenCV需要格式: [fx 0 cx; 0 fy cy; 0 0 1]
fprintf(fid, '    %.8f %.8f %.8f %.8f %.8f %.8f %.8f %.8f %.8f\n', ...
    stereoParams.CameraParameters1.IntrinsicMatrix(1,1), 0, stereoParams.CameraParameters1.IntrinsicMatrix(3,1), ...
    0, stereoParams.CameraParameters1.IntrinsicMatrix(2,2), stereoParams.CameraParameters1.IntrinsicMatrix(3,2), ...
    0, 0, 1);
fprintf(fid, '  </data>\n');
fprintf(fid, '</Camera1_Intrinsic>\n');

% 相机1畸变系数
fprintf(fid, '<Camera1_Distortion type_id="opencv-matrix">\n');
fprintf(fid, '  <rows>1</rows>\n');
fprintf(fid, '  <cols>5</cols>\n');
fprintf(fid, '  <dt>d</dt>\n');
fprintf(fid, '  <data>\n');
fprintf(fid, '    %.8f %.8f %.8f %.8f %.8f\n', ...
    stereoParams.CameraParameters1.RadialDistortion(1), ...
    stereoParams.CameraParameters1.RadialDistortion(2), ...
    stereoParams.CameraParameters1.TangentialDistortion(1), ...
    stereoParams.CameraParameters1.TangentialDistortion(2), ...
    stereoParams.CameraParameters1.RadialDistortion(3));
fprintf(fid, '  </data>\n');
fprintf(fid, '</Camera1_Distortion>\n');

% 相机2内参 - 修正：MATLAB矩阵格式转换为OpenCV格式
fprintf(fid, '<Camera2_Intrinsic type_id="opencv-matrix">\n');
fprintf(fid, '  <rows>3</rows>\n');
fprintf(fid, '  <cols>3</cols>\n');
fprintf(fid, '  <dt>d</dt>\n');
fprintf(fid, '  <data>\n');
% MATLAB IntrinsicMatrix格式: [fx 0 0; 0 fy 0; cx cy 1]
% OpenCV需要格式: [fx 0 cx; 0 fy cy; 0 0 1]
fprintf(fid, '    %.8f %.8f %.8f %.8f %.8f %.8f %.8f %.8f %.8f\n', ...
    stereoParams.CameraParameters2.IntrinsicMatrix(1,1), 0, stereoParams.CameraParameters2.IntrinsicMatrix(3,1), ...
    0, stereoParams.CameraParameters2.IntrinsicMatrix(2,2), stereoParams.CameraParameters2.IntrinsicMatrix(3,2), ...
    0, 0, 1);
fprintf(fid, '  </data>\n');
fprintf(fid, '</Camera2_Intrinsic>\n');

% 相机2畸变系数
fprintf(fid, '<Camera2_Distortion type_id="opencv-matrix">\n');
fprintf(fid, '  <rows>1</rows>\n');
fprintf(fid, '  <cols>5</cols>\n');
fprintf(fid, '  <dt>d</dt>\n');
fprintf(fid, '  <data>\n');
fprintf(fid, '    %.8f %.8f %.8f %.8f %.8f\n', ...
    stereoParams.CameraParameters2.RadialDistortion(1), ...
    stereoParams.CameraParameters2.RadialDistortion(2), ...
    stereoParams.CameraParameters2.TangentialDistortion(1), ...
    stereoParams.CameraParameters2.TangentialDistortion(2), ...
    stereoParams.CameraParameters2.RadialDistortion(3));
fprintf(fid, '  </data>\n');
fprintf(fid, '</Camera2_Distortion>\n');

% 旋转矩阵 - 修正：移除不必要的转置操作
fprintf(fid, '<Rotation_Matrix type_id="opencv-matrix">\n');
fprintf(fid, '  <rows>3</rows>\n');
fprintf(fid, '  <cols>3</cols>\n');
fprintf(fid, '  <dt>d</dt>\n');
fprintf(fid, '  <data>\n');
% 注意：移除转置操作(')，直接使用MATLAB旋转矩阵
% MATLAB和OpenCV都使用行优先存储，无需转置
fprintf(fid, '    %.8f %.8f %.8f %.8f %.8f %.8f %.8f %.8f %.8f\n', stereoParams.RotationOfCamera2);
fprintf(fid, '  </data>\n');
fprintf(fid, '</Rotation_Matrix>\n');

% 平移向量
fprintf(fid, '<Translation_Vector type_id="opencv-matrix">\n');
fprintf(fid, '  <rows>1</rows>\n');
fprintf(fid, '  <cols>3</cols>\n');
fprintf(fid, '  <dt>d</dt>\n');
fprintf(fid, '  <data>\n');
fprintf(fid, '    %.8f %.8f %.8f\n', stereoParams.TranslationOfCamera2);
fprintf(fid, '  </data>\n');
fprintf(fid, '</Translation_Vector>\n');

fprintf(fid, '</opencv_storage>\n');
fclose(fid);
fprintf('OpenCV格式参数已保存至: %s\n', xmlFileName);

% View reprojection errors
h1=figure; showReprojectionErrors(stereoParams);

% Visualize pattern locations
h2=figure; showExtrinsics(stereoParams, 'CameraCentric');

% Display parameter estimation errors
displayErrors(estimationErrors, stereoParams);

% You can use the calibration data to rectify stereo images.
I2 = imread(imageFileNames2{1});
[J1, J2] = rectifyStereoImages(I1, I2, stereoParams);

% See additional examples of how to use the calibration data.  At the prompt type:
% showdemo('StereoCalibrationAndSceneReconstructionExample')
% showdemo('DepthEstimationFromStereoVideoExample')